# QGBx
<img width="1600" height="300" alt="QGBXhEADER" src="https://github.com/user-attachments/assets/90c3af9a-2f7b-4386-a4de-aeb187c13ebf" />

QGBx is an open-source, extensible package designed as a submission for the <a href="https://www.thewiser.org/quantum-walks-monte-carlo" target="_blank">Project 1:</a> "Quantum Walks and Monte Carlo" hosted by the Wiser-Womanium Quantum Summer Program. This package serves as a sandbox for generating several statistical distributions using different Variational Multi-Dimensional Quantum Galton Board architectures, mainly derived from the <a href="https://arxiv.org/abs/2202.01735"> Universal Statistical Distribution</a> paper by Mark Carney & Ben Varcoe., along with the authors’ efforts to optimize its structure and results for various uses under different noiseless and noisy quantum simulations and even an end-point to run the generated circuits on a real QPU.

## Installation

You can install QGBx using

```bash
pip install --upgrade qgbx
```

## Usage

QGBx was designed to be extensible in the future, where other Distributions, Devices, Visualization, and Analysis methods can be supported through the same architecture for educational purposes of studying the behavior of the Galton board under both classical and quantum physics, where it was proven that it may help to achieve universal statistical simulators and probability distributions' encoders.

The diagram below shows the relationship between the different objects and the steps of creating, simulating, and retrieving results using QGBx:

<p align="center">
  <img src="https://github.com/user-attachments/assets/188ead0c-ddd5-4356-9b2f-eaad6d1d27da" 
       alt="Qgbx Diagram Usage drawio" 
       width="700" />
</p>

### 1. Creating a Device: 

QGBx supports two kinds of `Device`: **Simulators** and **Real Devices**.

- **Simulators**  
  - Noiseless all-to-all simulators: `PennylanDefaultQubit` and `QiskitAerSimulator`.  
  - Noisy simulator: `QiskitFakeTorino` — simulates the noise effects of the Heron IBM Torino device.  

- **Real Devices**  
  - `IBM_Torino`: Runs your generated circuit on the real QPU.  
    > Requires a personal IBM token and a CRN code for a created instance.

You can create a device object using QGBx as follows:

```python
# Import the desired device class
from QGBx.devices import QiskitAerSimulator, PennylanDefaultQubit, QiskitFakeTorino, IBM_Torino

# Create a PennylanDefaultQubit device (noiseless simulator)
dev = PennylanDefaultQubit(shots=1000)

# Create a QiskitAerSimulator device (noiseless simulator)
dev = QiskitAerSimulator(shots=1000)

# Create a QiskitFakeTorino device (noisy simulator replicating IBM Torino)
dev = QiskitFakeTorino(ai_optimized=False, optimization_level=0, ai_optimization_level=0, shots=1000)

# Create an IBM_Torino device (real QPU) - requires IBM token and CRN code
dev = IBM_Torino(token="YOUR_IBM_TOKEN", instance_CRN="YOUR_CRN_CODE", optimization_level=1, shots=1000)
```
> **Note:**  
> - `shots`: The number of circuit executions (measurements).  
> - `optimization_level`: Qiskit's built-in preset pass manager circuit optimization level (0–3). Higher values can reduce circuit depth but may change gate structure.
> - `ai_optimized`: Boolean (`True`/`False`). Enables or disables the generate_ai_pass_manager.  
> - `ai_optimization_level`: QGBx's AI-based optimization level (0–3). Controls how much the ai_pass manager try to optimize circuit depth and transpilation.  

### 2. Creating a Distribution

QGBx supports three built-in distributions:  

- `Gaussian` — Which is essentially a binomial distribution that converges toward a Gaussian distribution under the Laplace–de Moivre theorem when the number of layers of the Galton board becomes large.
  
```python
from QGBx.distributions import Gaussian

# p is a parameter of the binomial distribution that controls its bias (0.5 is centered)
dist = Gaussian(dev, p=0.4) 
```

- `Exponential` — A distribution where the probabilities follow an exponential decay pattern, defined by a rate parameter (λ).

```python
from QGBx.distributions import Exponential

# rate is λ (lambda) of the exponential function
dist = Exponential(dev, rate=0.5)
```
 

- `Hadamard_QW` — A quantum walk distribution generated by Hadamard operations, with different types that define the result of the walk (related to the input state — see the literature for more).

```python
from QGBx.distributions import HadamardQW

# type defines the result of the Hadamard walk (related to the input state)
# type options: ["Symmetric", "Asymmetric_Right", "Asymmetric_Left"]
dist = HadamardQW(dev, type="Symmetric")
```  

The distribution object will then be filled with the results of the simulation and its ideal (theoretical) counterpart in the next step.  

The package also gives the user the ability to create a custom Galton board by manipulating the probabilities of pegs in two ways:  
- Per peg — each individual peg of the Galton board gets its own probability (of going left or right) using `PegControlled`.  
- Per layer — all pegs of the same layer get the same probability using `LayerControlled` *(not yet tested)*.  

The user can give specific probabilities for each peg (or layer) or can set a target probability they want, and the package will try to numerically (variationally) tune the pegs (or layers) for that specific target (if possible) using the *least squares* method.  

> The user can also directly define the angles of the RX gates. See the structure of the circuits to better understand.

For this distribution the target probabilities "target=" (and effectively the angles "angles=") should be a list encoded as shown in the picture below:

<p align="center">
  <img src="https://github.com/user-attachments/assets/1efa4e38-c473-4fc9-976e-bb057f23ac22" 
       alt="PegsNaming drawio"
       width="500" />
</p>

The code for it is like the following:

```python
from QGBx.distributions import PegControlled

# probs (and angles) should be a list encoded as shown in the picture above
dist = PegControlled(device, angles=None, probs=None, optimizer="least_squares", target=None)
```

There are also the `GaussianOp` and `ExponentialOp`, which follow the same logic of the Galton board but use another circuit designed by the authors for the purpose of the Project. This alternative design overcomes many shortcomings in circuit depth and efficiency compared to the main one proposed in the *Universal Statistical Simulator* method.  

They can be instantiated as follows:  

```python
from QGBx.distributions import ExponentialOp, GaussianOp

dist = ExponentialOp(dev, rate=0.5) # rate is λ (lambda) of the exponential function

dist = GaussianOp(dev, p=0.4) # p is a parameter of the binomial distribution that controls its bias (0.5 is centered)
```


